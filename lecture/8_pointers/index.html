<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Arrays</title>
	<meta name="description" content="pointers, references, memory addressing">
	<meta name="keywords" content="c, c++">
	<meta name="author" content="Pavel Karpovich">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="icon" type="image/png" href="../../icon.png">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	
	<link rel="stylesheet" href="../../css/custom.css" />
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? "../../css/print/pdf.css" : "../../css/print/paper.css";
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<script src="../../js/theme.js"></script>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Основы алгоритмизации и программирования</h1>
                    <h2>Квантовая механика мира программирования, или</h2>
                    <h3>Работа с указателями</h3>
                    <div>
                        <p style="display: inline-block;">
                            Pavel Karpovich / 
                        </p>
                        <a href="https://github.com/tgjmjgj" class="icon-button github">
                            <i class="fa fa-github"></i><span></span>
                        </a>
                        <a href="https://facebook.com/paradox7master" class="icon-button facebook">
                            <i class="fa fa-facebook"></i><span></span>
                        </a>
                    </div>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
            </section>
            <section>
                <section>
                    <h1>Указатели</h1>
                    <blockquote>
                        Указатель – это объект, значением которого служит адрес другого объекта
                        (переменной, константы, другого указателя) или функций.
                    </blockquote>
                </section>
                <section>
                    <h1>Объявление указателя</h1>
                    <blockquote>
                        Формат объявления указателя:
                        <p><span class="blue">спецификатор_типа</span>* идентификатор</p>
                        <p>
                            Спецификатор_типа задает тип объекта и может быть 
                            любого основного типа, типа структуры или void. 
                        </p>
                    </blockquote>
                    <pre><code class="cpp">
char *pz;               // указатель на char
int *pk, *pi;           // указатели на int
float *pf;              // указатель на float
                    </code></pre>
                </section>
                <section>
                    <p>
                        Тип указателя должен однозначно соответствовать типу значения,
                        на адрес которого он указывает.
                    </p>
                    <pre><code class="cpp">
int name1 = 555;
int* pnm1;
float *pnm2;
char * pnm3;

pnm1 = &amp;name1;          // работает
pnm2 = &amp;name1;          // ошибка
pnm3 = (char*)&amp;name1;   // работает

                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Память компьютера</h2>
                    <p>
                        Память компьютера состоит из огромного количества байт.
                        У каждого байта в памяти есть свой уникальный адрес (номер).
                    </p>
                    <div style="display: inline-block;">
                        <pre><code class="cpp">
int main()
{

    return 0;
}
                        </code></pre>
                    </div>
                    <img style="float: right;" src="img/memory.jpg">
                </section>
                <section>
                    <h2>Переменная в памяти</h2>
                    <div style="display: inline-block;">
                        <pre><code class="cpp">
int main()
{
    int num;

    // вывод адреса num
    printf("%p \n", &num);
    // 0133FDBD

    return 0;
}
                        </code></pre>
                    </div>
                    <img style="float: right;" src="img/memory2.jpg">
                </section>
                <section>
                    <h2>Вторая переменная</h2>
                    <div style="display: inline-block;">
                        <pre><code class="cpp">
int main()
{
    int num;
    int* p1 = &amp;num;
    // 0133FDBD

    double big = 12.562;
    double* p2 = &amp;big;
    // 0133FDB5

    return 0;
}
                        </code></pre>
                    </div>
                    <img style="float: right;" src="img/memory3.jpg">
                </section>
                <section>
                    <h2>И еще массив</h2>
                    <div style="display: inline-block;">
                        <pre><code class="cpp">
int main()
{
    int num;
    int* p1 = &amp;num;
    // 0133FDBD

    double big = 12.562;
    double* p2 = &amp;big;
    // 0133FDB5

    char str[10] = "avial";
    char* p3 = str;
    // 0133FDAB

    return 0;
}
                        </code></pre>
                    </div>
                    <img style="float: right;" src="img/memory4.jpg">
                </section>
            </section>
            <section>
                <h3>Ещё раз</h3>
                <p>
                    Обычные переменные хранят значения.
                </p>
                <blockquote>
                    Указатели хранят адреса этих значений.
                </blockquote>
                <pre><code class="cpp">
char sy = '%';
cout &lt;&lt; sy &lt;&lt; endl;         // Выведет %

char* pointer = &amp;sy;
cout &lt;&lt; pointer &lt;&lt; endl;    // Выведет шестнадцатеричную ерунду

int name = 42;
cout &lt;&lt; name &lt;&lt; endl;       // Выведет ответ на главный вопрос жизни, вселенной и всего такого

int* ptr = &amp;name;
cout &lt;&lt; ptr &lt;&lt; endl;        // Выведет шестнадцатеричную ерунду
                </code></pre>
            </section>
            <section>
                <section>
                    <h3>Как вывести значение по указателю?</h3>
                    <blockquote>
                        Ответ - операция <span class="purple">разыменования</span>.
                    </blockquote>
                    <p>
                        Разыменование, или косвенная адресация - получение переменной не напрямую,
                        а через указатель, содержащий адрес этой переменной.
                    </p>
                    <p>
                        Обращение с переменной через указатель с её адресом равносильно обращению 
                        с самой переменной. Т.е. допускается перезапись и изменение значения.
                    </p>
                </section>
                <section>
                    <h2>Указатель</h2>
                    <p>
                        По факту, переменная и указатель на эту переменную обращается 
                        к одной и той же памяти, к одному и тому же значению.
                    </p>
                    <blockquote>
                        <ins>
                            Меняя значение по указателю, изменится значение и переменной.
                            Аналогично, меняя значение в переменной, по указателю будет уже
                            новое изменённое значение.
                        </ins>
                    </blockquote>
                    <img src="img/pointer.jpg">
                </section>
                <section>
                    <h3>Использование разыменованного указателя</h3>
                    <pre><code class="cpp">
int x = 10;
int *p = &amp;x;
printf("Address = %p \n", p);
printf("x = %d \n", *p);

*p += 1;
printf("Address = %p \n", p);   // адрес не изменится
printf("x = %d \n", *p);        // 11
printf("x = %d \n", x);         // 11

x /= 2;
printf("x = %d \n", *p);        // 5
printf("x = %d \n", x);         // 5
                    </code></pre>
                </section>
                <section>
                    <h3>* и &amp;</h3>
                    <p>
                        Операция разыменования * в некотором смысле является 
                        обратной операции получения адреса &amp;.
                    </p>
                    <pre><code class="cpp">
int eger = 27;

int* ptr = &amp;eger;

int b = *ptr;           // b = 27

int c = *&amp;b;            // c = b = 27

bool isr = &*ptr == &amp;*&amp;eger;    // true
bool isr = &*ptr == &amp;*&amp;c;       // false
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h3>Пример</h3>
                    <pre><code class="cpp">
char c = 'N';
int d = 10;
short s = 2;
    
char *pc = &amp;c;          // получаем адрес переменной с типа char
int *pd = &amp;d;           // получаем адрес переменной d типа int
short *ps = &amp;s;         // получаем адрес переменной s типа short
    
printf("Variable c: address=%p \t value=%c \n", pc, *pc);
printf("Variable d: address=%p \t value=%d \n", pd, *pd);
printf("Variable s: address=%p \t value=%hd \n", ps, *ps);
return 0;
                    </code></pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <img src="img/multi_pointers.jpg">
                    <pre><code class="cpp">
double dbl = 6273e+25;
double* p1 = &amp;dbl;
double* p2 = p1;

dbl = 33.543;
double* p3 = &amp;dbl;

*p2 -= 30;

cout &lt;&lt; dbl &lt;&lt; " : " &lt;&lt; *p1 &lt;&lt; " : " 
    &lt;&lt; *p2 &lt;&lt; " : " &lt;&lt; *p3 &lt;&lt; endl;
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Указатель в никуда</h2>
                    <p>
                        Использование неинициализированных указателей опасно (можно перезаписать произвольную память). 
                        Объявляя указатель, необходимо инициализировать его адресом определенной переменной или нулем. 
                    </p>
                    <p>
                        Поэтому в C++ существует специальное ключевое слово <span class="blue">nullptr</span>,
                        для обозначения пустого указателя (или устаревший вариант, <span class="blue">NULL</span>).
                    </p>
                    <pre><code class="cpp">
int *pm = nullptr;     // указатель, не указывающий ни на что
...
if (pm == nullptr)
    cout &lt;&lt; endl &lt;&lt; "Нулевой указатель" &lt;&lt; endl;
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Ссылки</h2>
                    <p>
                        Ссылка - объект, ссылающийся на другую переменную.
                    </p>
                    <blockquote>
                        Формат объявления ссылки:
                            <p><span class="blue">спецификатор_типа</span>& идентификатор</p>
                    </blockquote>
                    <p>
                        При изменении ссылки изменения будут отражаться и на исходной переменной.
                    </p>
                    <blockquote>
                        Переменная и ссылки на неё - два имени одного и того же объекта в памяти.
                    </blockquote>
                </section>
                <section>
                    <h2>Ссылки</h2>
                    <p>
                        Ссылка всегда должна ссылаться на существующую переменную.
                    </p>
                    <pre><code class="cpp">
short int g = 13;

short int * pointer = &amp;g;   // Указатель на g
short int & reference = g;      // Ссылка на g
short int b = g;                // Копия g

cout &lt;&lt; "Переменная: " &lt;&lt; g &lt;&lt; endl;          // 13
cout &lt;&lt; "Указатель: " &lt;&lt; pointer &lt;&lt; endl;     // 043D3EA2
cout &lt;&lt; "Ссылка: " &lt;&lt; reference &lt;&lt; endl;      // 13
cout &lt;&lt; "Копия: " &lt;&lt; b &lt;&lt; endl;               // 13

++g;
cout &lt;&lt; "Переменная: " &lt;&lt; g &lt;&lt; endl;                          // 14
cout &lt;&lt; "Разыменованный указатель: " &lt;&lt; pointer &lt;&lt; endl;      // 14
cout &lt;&lt; "Ссылка: " &lt;&lt; reference &lt;&lt; endl;                      // 14
cout &lt;&lt; "Копия: " &lt;&lt; b &lt;&lt; endl;                               // 13

++reference;
cout &lt;&lt; "Переменная: " &lt;&lt; g &lt;&lt; endl;                          // 15
cout &lt;&lt; "Разыменованный указатель: " &lt;&lt; pointer &lt;&lt; endl;      // 15
cout &lt;&lt; "Ссылка: " &lt;&lt; reference &lt;&lt; endl;                      // 15
cout &lt;&lt; "Копия: " &lt;&lt; b &lt;&lt; endl;                               // 13

++*pointer;
cout &lt;&lt; "Переменная: " &lt;&lt; g &lt;&lt; endl;                          // 16
cout &lt;&lt; "Разыменованный указатель: " &lt;&lt; pointer &lt;&lt; endl;      // 16
cout &lt;&lt; "Ссылка: " &lt;&lt; reference &lt;&lt; endl;                      // 16
cout &lt;&lt; "Копия: " &lt;&lt; b &lt;&lt; endl;                               // 13

g = nullptr;                // ошибка
pointer = nullptr;          // pointer больше не указывает на g
reference = nullptr;        // ошибка
b = nullptr;                // ошибка

                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h1>Операции над указателями</h1>
                    <p>
                        Указатели можно использовать в следующих операциях:
                    </p>
                    <ul>
                        <li>Присваивание (=)</li>
                        <li>Разыменование (*)</li>
                        <li>Взятие адреса (&)</li>
                        <li>Сравнения (==, !=, &lt;, &gt;, &lt;=, &gt;=)</li>
                        <li>Некоторая арифметика (+, -, ++, --)</li>
                    </ul>
                </section>
                <section>
                    <h2>Присваивание</h2>
                    <p>
                        Указателю можно присвоить адрес любого объекта в памяти, или 
                        специальные адреса <span class="blue">nullptr</span> и <span class="blue">NULL</span>.
                    </p>
                    <p>
                        Числа присваивать нельзя (без явного приведения к типу указателя).
                    </p>
                    <pre><code class="cpp">
char symb = '=';
char t;
int kk = -13;

char* pc = &amp;symb;
pc = &amp;t;
pc = &amp;kk;                   // ошибка

printf("%p", &kk);              // 006FFB90

int *ptr_i = 0x006FFB90;        // ошибка
ptr_i = (int*)0x006FFB90;

printf("%d", *ptr_i);           // -13
                    </code></pre>
                </section>
                <section>
                    <h2>Разыменование</h2>
                    <p>
                        Разыменование - специальная операция, применимая только к указателям.
                    </p>
                    <br/>
                    <p>
                        Её примеров мы уже насмотрелись.
                    </p>
                </section>
                <section>
                    <h2>Взятие адреса</h2>
                    <p>
                        Да-да. У указателя тоже есть адрес.
                    </p>
                    <p>
                        Указатель хранит адрес переменной. Хранит. Значит хранит где-то, а где же 
                        еще, кроме как в памяти.
                    </p>
                    <blockquote>
                        Указатель на переменную занимает в памяти 2, 4 или 8 байтов.
                        2 байта на 16 битных системах, 4 на 32 битных и 8 на 64 битных.
                    </blockquote>
                    <p>
                        Размер указателя на функцию может достигать 24 байт.
                    </p>
                </section>
                <section>
                    <h3>Адрес указателя</h3>
                    <pre><code class="cpp">
int num = 888;
int* pn = &amp;num;

printf("%d", *pn);          // Значение переменной
printf("%p", pn);           // Указатель - адрес переменной
printf("%p", &amp;pn);          // Адрес указателя

printf("%p", &amp;&amp;num);    // Ошибка - у адреса нет адреса

                    </code></pre>
                </section>
                <section>
                    <h3>Дополним пример с памятью</h3>
                    <div style="display: inline-block;">
                        <pre><code class="cpp">
int main()
{
    int num;
    int* p1 = &amp;num;
    // &amp;num = 0133FDBD
    // &amp;p1 = 0133FDB9

    double big = 12.562;
    double* p2 = &amp;big;
    // &amp;big = 0133FDB1
    // &amp;p2 = 0133FDAD

    char str[10] = "avial";
    char* p3 = str;
    // &amp;str = 0133FDA3
    // &amp;p3 = 0133FD9F

    return 0;
}
                        </code></pre>
                    </div>
                    <img style="float: right;" src="img/memory5.jpg">
                </section>
                <section>
                    <h2>Указатели на указатели на указатели на указатели...</h2>
                    <p>
                        Раз у указателя есть адрес, то можно сделать указатель на указатель.
                    </p>
                    <pre><code class="cpp">
float e = 2.7182;
float* pe = &amp;e;
float** ppe = &amp;pe;
float*** pppe = &amp;ppe;

printf("Вещественное число e: %f", e);
printf("Через указатель : %f", *pe);
printf("Через указатель на указатель : %f", **pe);
printf("Через указатель на указатель на указатель : %f", ***pe);
                    </code></pre>
                    <p>
                        Как правило, такие конструкции применяются при работе с многомерными массивами.
                    </p>
                </section>
                <section>
                    <h3>Пояснение</h3>
                    <img src="img/pointers_to_pointers.jpg">
                </section>
                <section>
                    <h2>Операции сравнения</h2>
                    <p>
                        Указатели можно сравнивать между собой всеми доступными
                        операторами сравнения (==, !=, &lt;, &gt;, &lt;=, &gt;=).
                    </p>
                    <p>
                        Сравниваться будут значения адресов, записанных в указателях, 
                        как простые числа.
                    </p>
                    <p>
                        Сравнение указателей бывает полезно при работе с массивами.
                    </p>
                </section>
                <section>
                    <h3>Примеры сравнений</h3>
                    <pre><code class="cpp">
int a = 3;
int b = 17;

int* pa = &amp;a;           //  003FF47A
int* pb = &amp;b;           //  003FF471

bool b1 = (a &lt; b);               // true
bool b2 = (pa &lt; pb);             // false

int mas[2] = { 14, -234 };
pa = &mas[0];
pb = &mas[1];
if (pa > pb)
{
    printf("%d идёт после %d", *pa, *pb);
}
else
{
    printf("%d идёт после %d", *pb, *pa);
}
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Арифметика указателей</h2>
                    <p>
                        К указателям можно прибавлять значения, и отнимать значения.
                        Т.е. доступны операции + и -, а также их сокращённые формы +=, -=, ++ и --.
                    </p>
                    <p>
                        В качестве вторых операндов могут выступать целые числа и другие указатели.
                    </p>
                    <blockquote>
                        В результате операций изменяется адрес, на который указывает указатель.
                    </blockquote>
                </section>
                <section>
                    <h2>Особенности вычислений</h2>
                    <p>
                        Но эти операции выполняются по особенному, не так как с обычными числами.
                    </p>
                    <blockquote>
                        <span class="red">
                            При добавлении к указателю числа N, адрес смещается 
                            на расстояние в N элементов <ins>типа указателя</ins>.
                        </span>
                    </blockquote>
                    <p>
                        При прибавлении адрес увеличивается, при вычитании уменьшается.
                    </p>
                </section>
                <section>
                    <h2>Типы указателей</h2>
                    <p>
                        Если указатель указывает на тип <span class="blue">int</span>, то 
                        прибавление к адресу 1 увеличит его на <span class="blue">4 байта</span>
                    </p>
                    <p>
                        Для типа <span class="blue">char</span> адрес увеличится на <span class="blue">1 байт</span>.
                    </p>
                    <p>
                        Для типа <span class="blue">double</span> на <span class="blue">8</span>.
                    </p>
                    <p>
                        И т.д.
                    </p>
                </section>
                <section>
                    <h3>Пример адресной арифметики</h3>
                    <pre><code class="cpp">
int eps = 1243;

int* pp = &amp;eps;		// 00E1F442
pp += 1;			// 00E1F442 + 4 = 00E1F446
pp += 3;			// 00E1F446 + C = 00E1F452

char ch = 'F';

char* pch = &amp;ch;	// 00E1F320
++pch;				// 00E1F320 + 1 = 00E1F321

short int shi = 874;

short int* pshi = &amp;shi;		// 00E1F2F4
pshi = pshi - 4;			// 00E1F2F4 - 8 = 00E1F2EC
                    </code></pre>
                </section>
                <section>
                    <h2>Схема смещения указателя на int</h2>
                    <div style="display: inline-block; ">
                        <pre><code class="cpp">
int a = 423;
int *pa = &amp;a;

for (int i = 0; i &lt; 6; ++i)
{
    cout &lt;&lt; pa &lt;&lt; endl;
    ++pa;

}
                        </code></pre>
                    </div>
                    <iframe style="float: right;" src="https://giphy.com/embed/5QTIpRZ6JlOLOoU27F" width="480" height="339" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
                </section>
                <section>
                    <h2>Схема смещения указателя на double</h2>
                    <div style="display: inline-block; ">
                        <pre><code class="cpp">
int num = 7;

double db_val = 5e+8;
double *pd = &amp;db_val;

for (int i = 0; i &lt; 4; ++i)
{
    cout &lt;&lt; pd &lt;&lt; endl;
    ++pd;

}
                        </code></pre>
                    </div>
                    <iframe style="float: right;" src="https://giphy.com/embed/lVBMMwVmNZwRudXGcj" width="480" height="339" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
                </section>
                <section>
                    <h2>Разность указателей</h2>
                    <p>
                        От одного указателя можно отнять другой указатель, чтобы получить 
                        разницу их адресов.
                    </p>
                    <p>
                        <ins>
                            Разница высчитывается в количестве элементов типа указателя.
                        </ins>
                    </p>
                    <pre><code class="cpp">
int ek = 3;     // 00FFAA10
int et = 45;    // 00FFAA20
int* pek = &amp;ek;
int* pet = &amp;et;

cout &lt;&lt; pek - pet &lt;&lt; endl;      // 4

double dy = 54.3;   // 00FFAA10
double dx;          // 00FFAA20
double* pdy = &amp;dy;
double* pdx = &amp;dx;

cout &lt;&lt; pdy - pdx &lt;&lt; endl;      // 2

                    </code></pre>
                </section>
                <section>
                    <h3>Вычитание указателей</h3>
                    <p>
                        Адреса нельзя складывать.
                    </p>
                    <p>
                        Можно вычитать только указатели на одинаковые типы.
                    </p>
                    <pre><code class="cpp">
char chap;
bool bip;
char* pach = &amp;chap;
bool* pub = &amp;bip;
bool* pub2 = &amp;pub2;

pach - pub;         // Ошибка
pub + pub2;         // Ошибка

cout &lt;&lt; Разница в памяти между элементами составляет " &lt;&lt; pub - pub2 &lt;&lt; " байт.\n";
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Указатели и массивы</h2>
                    <p>
                        <span class="red">Элементы массива располагаются в памяти 
                        <ins>строго последовательно</ins>.</span>
                    </p>
                    <pre><code class="cpp">
int arr[5];
                   </code></pre>
                    <img src="img/arr.jpg" />
                </section>
                <section>
                    <h2>Имя массива</h2>
                    <p>
                        На самом деле, имя массива - это указатель на его нулевой элемент.
                    </p>
                    <p>
                        Поэтому нельзя получить адрес массива оператором &amp;.
                    </p>
                    <pre><code class="cpp">
int mas[2] = { 1, 2 };
cout &lt;&lt; mas &lt;&lt; endl;        // Выведет адрес нулевого элемента массива
cout &lt;&lt; *mas &lt;&lt; endl;       // Значение нулевого элемент массива - 1

// Т.е.
mas[0] == *mas;
&amp;mas[0] == mas;

// Тогда как получить доступ к mas[1]?
mas[1] = ??
                    </code></pre>
                </section>
                <section>
                    <h3>Нулевой элемент</h3>
                    <img src="img/arr_1.jpg" />
                </section>
                <section>
                    <h3>Первый элемент</h3>
                    <img src="img/arr_2.jpg" />
                </section>
                <section>
                    <h2>Адресация элементов массива</h2>
                    <pre><code class="cpp">
double mass[4] = { 4.3, 0.1, -34.2, 6.31, 3.0 };

cout &lt;&lt; "0. Адрес: " &lt;&lt; mass &lt;&lt; "  Значение: " &lt;&lt; *mass &lt;&lt; endl;
cout &lt;&lt; "1. Адрес: " &lt;&lt; mass + 1 &lt;&lt; "  Значение: " &lt;&lt; *(mass + 1) &lt;&lt; endl;
cout &lt;&lt; "2. Адрес: " &lt;&lt; mass + 2 &lt;&lt; "  Значение: " &lt;&lt; *(mass + 2) &lt;&lt; endl;
cout &lt;&lt; "3. Адрес: " &lt;&lt; mass + 3 &lt;&lt; "  Значение: " &lt;&lt; *(mass + 3) &lt;&lt; endl;
                    </code></pre>
                    <pre><code class="cpp">
short arr[3] = { 4, 12, 7 };
int a = *arr + 1;
*(arr + 1) = a;

// arr = { 4, 5, 7 }
                    </code></pre>
                </section>
                <section>
                    <h2>Перебор элементов массива через указатель</h2>
                    <pre><code class="cpp">
const int sz = 20;
char mas[sz] = "abcdefghjklmnopqrst";
for (char* cur = mas; cur &lt; mas + sz; ++cur)
{
    printf("%c\n", *cur);
    // cur -- адрес текущего элемента массива
    // *cur -- его значение
}
                    </code></pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre><code class="cpp">
int arr[100];
int rmax = 10;
int rmin = 10;
int array_size;

cout &lt;&lt; "Введите размер массива" &lt;&lt; endl;
cin &gt;&gt; array_size;

srand(time(0));

for (int i = 0; i &lt; array_size; ++i)
{
    *(arr + i) = rand() % rmax - rmin;
    cout &lt;&lt; *(arr + i) &lt;&lt; endl;
}

int avg = 0;
for (int* tmp = arr; tmp &lt; arr + 100; ++tmp)
{
    avg += *tmp;
}
avg /= array_size;
cout &lt;&lt; "Средний элемент массива: " &lt;&lt; avg &lt;&lt; endl;
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Неизменный указатель</h2>
                    <p>
                        Хоть имя массива и является указателем, его нельзя изменять.
                    </p>
                    <pre><code class="cpp">
int mas[10];

mas++;               // Ошибка
mas = &amp;mas[4];       // Ошибка
                    </code></pre>
                    <p>
                        Это потому, что имя массива - константный указатель.
                    </p>
                </section>
                <section>
                    <h2>Константные указатели</h2>
                    <p>
                        Для объявления константного указателя необходимо приписать ключевое слово 
                        <span class="blue">const</span> после звёздочки.
                    </p>
                    <pre><code class="cpp">
тип* const имя = &переменная;
                    </code></pre>
                    <p>
                        Константный указатель всегда указывает на один и тот же адрес, его нельзя перезаписать.
                    </p>
                    <p>
                        Константный указатель нельзя объявить без инициализации.
                    </p>
                    <pre><code class="cpp">
float ff = 23.4f;
float f2 = -3.7f;
float* const pf;    // Ошибка
float* const pf = &amp;ff;
pf = &amp;f2;           // Ошибка
                    </code></pre>
                </section>
                <section>
                    <h2>Указатель на константу</h2>
                    <p>
                        Для объявления указателя на константу необходимо приписать ключевое слово 
                        <span class="blue">const</span> перед типом указателя.
                    </p>
                    <pre><code class="cpp">
const тип* имя;
                    </code></pre>
                    <p>
                        Указатель на константу не позволяет изменять значение в той ячейке памяти, на
                        которую он указывает. Но адрес указателя менять можно.
                    </p>
                </section>
                <section>
                    <h2>Различия</h2>
                    <pre><code class="cpp">
int a = 2;
int b = 5;

// Константный указатель
int* const pc = &amp;a;
*pc = 10;           // можно
pc = &amp;b;            // нельзя

// Указатель на константу
const int* cp;
cp = &amp;a;        // можно
*cp = -2;       // нельзя
cp = &amp;b;        // можно
++(*cp);        // нельзя
cp = nullptr;

// Константный указатель на константу
const short* const pname = &amp;a;
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Передача указателя в функцию</h2>
                    <p>
                        Указатель, как обычная переменная, может быть передан в аргумент функции.
                    </p>
                    <pre><code class="cpp">
void some_function(char* pointer);
                    </code></pre>
                    <p>
                        При передаче массива в функцию передаётся указатель на его нулевой элемент.
                        Поэтому для таких массивов перестаёт работать функция sizeof() - программа 
                        воспринимает массив просто как указатель.
                    </p>
                </section>
                <section>
                    <h3>Пример передачи массива</h3>
                    <pre><code class="cpp">
bool swap(int* mas, int first, int second)
{
    int temp = mas[first];
    mas[first] = mas[second];
    mas[second] = temp;
}

int main()
{
    int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    swap(a, 1, 5);
    swap(a, 1, 9);
    // a = { 1, 10, 3, 4, 5, 2, 7, 8, 9, 6 };
}
                    </code></pre>
                </section>
                <section>
                    <h2>Возврат указателя</h2>
                    <p>
                        Указатели также могут выступать возвращаемыми значениями функций.
                    </p>
                    <pre><code class="cpp">
float* function_name(float* arg)
{
    // ...
    return arg; 
}
                    </code></pre>
                    <blockquote>
                        <ins>Нельзя </ins> возвращать указатели на локальные переменные, созданные внутри функции.
                    </blockquote>
                </section>
                <section>
                    <h3>Почему же, почему</h3>
                    <p>
                        Локальные переменные существуют только в рамках своей функции. Если в функции объявить
                        указатель на локальную переменную, то внутри неё по адресу указателя будет находиться 
                        значение этой переменной. Но после завершения функции переменная перестанет существовать,
                        а возвращённый указатель будет продолжать ссылаться на её адрес.
                    </p>
                </section>
                <section>
                    <h3>Пример</h3>
                    <p>
                        Иногда это не будет работать:
                    </p>
                    <pre><code class="cpp">
float* get_average(int* mas, int size)
{
    float avg = 0;
    float* pavg = &amp;avg;
    for (int* current = mas; current &lt; mas + size; ++current)
    {
        *pavg += (float)*current;	// равнозначено *(float*)current
    }
    *pavg /= (float)size;
    return pavg;
}

int main()
{
    setlocale(LC_ALL, "rus");
    
    int arr[5] = { 1, 2, 3, 4, 5 };
    float* pa = get_average(arr, sizeof(arr) / sizeof(int));
    *pa *= 2;
    cout &lt;&lt; *pa &lt;&lt; endl;        // 0, а может быть 6, а может и ещё что-то
    return 0;
}
                    </code></pre>
                </section>
                <section>
                    <h3>Как можно разрешить подобную ситуацию</h3>
                    <p>
                        Одним из вариантов решения подобной ситуации заключается в использовании
                        параметра для возврата значения.
                    </p>
                    <pre><code class="cpp">
void get_average(int* mas, int size, float* ret_avg)
{
    *ret_avg = 0;
    for (int* current = mas; current &lt; mas + size; ++current)
    {
        *ret_avg += (float)*current;	// равнозначено *(float*)current
    }
    *ret_avg /= (float)size;
}

int main()
{
    setlocale(LC_ALL, "rus");
    
    int arr[5] = { 1, 2, 3, 4, 5 };
    float pa;
    get_average(arr, 5, &pa);
    pa *= 2;
    cout &lt;&lt; pa &lt;&lt; endl;        // 6
    return 0;
}
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h1>Указатели опасны</h1>
                    <img src="img/pointers_not_for_games.jpg">
                </section>
                <section>
                    <h3>Лезвие ножа</h3>
                    <p>
                        С одной стороны, указатели - невероятно мощный механизм, позволяющий 
                        <ins>при правильной эксплуатации</ins>
                        эффективно использовать память компьютера и вытворять с ней такие 
                        хитрые выкрутасы, что производительность вырастает в разы. 
                    </p>
                    <p>
                        Но вместе с тем использование указателей значительно увеличивает шансы 
                        "выстрелить себе в колено".
                    </p>
                    <p>
                        Любой неверный шаг в сторону - обращение не по тому адресу в памяти, 
                        может привести к поломке программы.
                    </p>
                </section>
                <section>
                    <h2>Ошибки при работе с указателями</h2>
                    <p>
                        Универсальный способ сломать программу с помощью указателей - 
                        записать значение туда, где ему быть не положено.
                    </p>
                    <pre><code class="cpp">
char a;
char* pa = &amp;a;

pa += 3;
*pa = 2;
                    </code></pre>
                    <p>
                        Итого, стек вызова повреждён:
                    </p>
                    <img src="img/stack_corrupted.jpg">
                </section>
            </section>

            <section>
                <h2>Что почитать дополнительно?</h2>
                <ul>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1XxoO8rXvNQvp3DHW5Q31DQES5JHZvLBQ#page=249">
                                <b>Главы 24-25</b> :<br>Г.Перри, Д. Миллер - Программирование на C для начинающих
                            </a>
                        </li>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1sGKwDAXw-JRHN2gyV1YOpdkxlosgixQb#page=641">
                                <b>Глава 17</b> :<br>Б.Страуструп - Принципы и практики программирования на C++
                            </a>
                        </li>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1LEiih0sJ41e1SXzf2tYCEnVFcs3eAIAn#page=505">
                                <b>Глава 8</b> :<br>Х.М.Дейтейл - Как программировать на C++
                            </a>
                        </li>
                </ul>
            </section>
            
		</div>
	</div>
	<aside id="presentable-icon" class="cpp">
        <a title="Содержание лекции" href="#/0/1">
            <i class="fa fa-list-ul fa-2x controls"></i>
        </a>
    </aside>
    <aside id="presentable-icon-close">
        <a title="К списку материалов" href="../../index.html#/1">
            <i class="fa fa-times fa-2x controls"></i>
        </a>
    </aside>
    <aside id="presentable-theme-picker">
        <div id="hidden-bar" class="invisible">
            <div>
                <div data-theme="beige" class="theme-circle theme-beige"></div>
                <div data-theme="black" class="theme-circle theme-black"></div>
                <div data-theme="blood" class="theme-circle theme-blood"></div>
                <div data-theme="league" class="theme-circle theme-league"></div>
                <div data-theme="moon" class="theme-circle theme-moon"></div>
                <div data-theme="night" class="theme-circle theme-night"></div>
                <div data-theme="serif" class="theme-circle theme-serif"></div>
                <div data-theme="simple" class="theme-circle theme-simple"></div>
                <div data-theme="sky" class="theme-circle theme-sky"></div>
                <div data-theme="solarized" class="theme-circle theme-solarized"></div>
                <div data-theme="white" class="theme-circle theme-white"></div>
            </div>
        </div>
        <div id="selected-theme" class="theme-circle"></div>
    </aside>
    <script src="../../js/bundle.min.js"></script>
</body>

</html>