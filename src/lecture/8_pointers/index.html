<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Arrays</title>
	<meta name="description" content="static arrays">
	<meta name="keywords" content="c, c++">
	<meta name="author" content="Edward & Albert">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Основы алгоритмизации и программирования</h1>
                    <h3>Работа с указателями</h3>
                    <div>
                        <p style="display: inline-block;">
                            Edward &amp; Albert / 
                        </p>
                        <a href="https://github.com/tgjmjgj" class="icon-button github">
                            <i class="fa fa-github"></i><span></span>
                        </a>
                        <a href="https://facebook.com/paradox7master" class="icon-button facebook">
                            <i class="fa fa-facebook"></i><span></span>
                        </a>
                    </div>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
            </section>
            <section>
                <section>
                    <h1>Указатели</h1>
                    <blockquote>
                        Указатель – это объект, значением которого служит адрес другого объекта
                        (переменной, константы, другого указателя) или функций.
                    </blockquote>
                </section>
                <section>
                    <h1>Объявление указателя</h1>
                    <blockquote>
                        Формат объявления указателя:
                        <p><span class="blue">спецификатор_типа</span>* идентификатор</p>
                        <p>
                            Спецификатор_типа задает тип объекта и может быть 
                            любого основного типа, типа структуры или void. 
                        </p>
                    </blockquote>
                    <pre>
                        <code class="cpp">
char *pz;               // указатель на char
int *pk, *pi;           // указатели на int
float *pf;              // указатель на float
                        </code>
                    </pre>
                </section>
                <section>
                    <p>
                        Тип указателя должен однозначно соответствовать типу значения,
                        на адрес которого он указывает.
                    </p>
                    <pre>
                        <code class="cpp">
int name1 = 555;
int* pnm1;
float *pnm2;
char * pnm3;

pnm1 = &amp;name1;          // работает
pnm2 = &amp;name1;          // ошибка
pnm3 = (char*)&amp;name1;   // работает

                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Память компьютера</h2>
                    <p>
                        Память компьютера состоит из огромного количества байт.
                        У каждого байта в памяти есть свой уникальный адрес (номер).
                    </p>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory.jpg">
                </section>
                <section>
                    <h2>Переменная в памяти</h2>
                    <p>
                        Память компьютера состоит из огромного количества байт.
                        У каждого байта в памяти есть свой уникальный адрес (номер).
                    </p>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{
    int num;

    // вывод адреса num
    printf("%p \n", &num);
    // 0133FDBD

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory2.jpg">
                </section>
                <section>
                    <h2>Вторая переменная</h2>
                    <p>
                        Память компьютера состоит из огромного количества байт.
                        У каждого байта в памяти есть свой уникальный адрес (номер).
                    </p>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{
    int num;
    int* p1 = &amp;num;
    // 0133FDBD

    float big = 12.562;
    char* p2 = &amp;big;
    // 0133FDA2

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory3.jpg">
                </section>
                <section>
                    <h2>И еще массив</h2>
                    <p>
                        Память компьютера состоит из огромного количества байт.
                        У каждого байта в памяти есть свой уникальный адрес (номер).
                    </p>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{
    int num;
    int* p1 = &amp;num;
    // 0133FDBD

    float big = 12.562;
    float* p2 = &amp;big;
    // 0133FDA2

    char str[10] = "avial";
    char* p3 = str;
    // 0133FDAC

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory4.jpg">
                </section>
            </section>
            <section>
                <h3>Ещё раз</h3>
                <p>
                    Обычные переменные хранят значения.
                </p>
                <blockquote>
                    Указатели хранят адреса этих значений.
                </blockquote>
                <pre>
                    <code class="cpp">
char sy = '%';
cout &lt;&lt; sy &lt;&lt; endl;         // Выведет %

char* pointer = &amp;sy;
cout &lt;&lt; pointer &lt;&lt; endl;    // Выведет шестнадцатеричную ерунду

int name = 42;
cout &lt;&lt; name &lt;&lt; endl;       // Выведет ответ на главный вопрос жизни, вселенной и всего такого

int* ptr = &amp;name;
cout &lt;&lt; ptr &lt;&lt; endl;        // Выведет шестнадцатеричную ерунду
                    </code>
                </pre>
            </section>
            <section>
                <section>
                    <h3>Как вывести значение по указателю?</h3>
                    <blockquote>
                        Ответ - операция <span class="purple">разыменования</span>.
                    </blockquote>
                    <p>
                        Разыменование, или косвенная адресация - получение переменной не напрямую,
                        а через указатель, содержайщий адрес этой переменной.
                    </p>
                    <p>
                        Обращение с переменной через указатель с её адресом равносильно обращению 
                        с самой переменной. Т.е. допускается перезапись и изменение значения.
                    </p>
                </section>
                <section>
                    <h2>Указатель</h2>
                    <p>
                        По факту, переменная и указатель на эту переменную обращается 
                        к одной и той же памяти, к одному и тому же значению.
                    </p>
                    <blockquote>
                        <ins>
                            Меняя значение по указателю, изменится значение и переменной.
                            Аналогично, меняя значение в переменной, по указателю будет уже
                            новое изменённое значение.
                        </ins>
                    </blockquote>
                    <img src="img/pointer.jpg">
                </section>
                <section>
                    <h3>Использование разыменованного указателя</h3>
                    <pre>
                        <code class="cpp">
int x = 10;
int *p = &amp;x;
printf("Address = %p \n", p);
printf("x = %d \n", *p);

*p += 1;
printf("Address = %p \n", p);   // адрес не изменится
printf("x = %d \n", *p);        // 11
printf("x = %d \n", x);         // 11

x /= 2;
printf("x = %d \n", *p);        // 5
printf("x = %d \n", x);         // 5
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>* и &amp;</h3>
                    <p>
                        Операция разыменования * в некотором смысле является 
                        обратной операции получения адреса &amp;.
                    </p>
                    <pre>
                        <code class="cpp">
int eger = 27;

int* ptr = &amp;eger;

int b = *ptr;           // b = 27

int c = *&amp;b;            // c = b = 27

bool isr = &*ptr == &amp;*&amp;eger;    // true
bool isr = &*ptr == &amp;*&amp;c;       // false
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="cpp">
char c = 'N';
int d = 10;
short s = 2;
    
char *pc = &amp;c;          // получаем адрес переменной с типа char
int *pd = &amp;d;           // получаем адрес переменной d типа int
short *ps = &amp;s;         // получаем адрес переменной s типа short
    
printf("Variable c: address=%p \t value=%c \n", pc, *pc);
printf("Variable d: address=%p \t value=%d \n", pd, *pd);
printf("Variable s: address=%p \t value=%hd \n", ps, *ps);
return 0;
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <img src="img/multi_pointers.jpg">
                    <pre>
                        <code class="cpp">
double dbl = 6273e+25;
double* p1 = &amp;dbl;
double* p2 = p1;

dbl = 33.543;
double* p3 = &amp;dbl;

*p2 -= 30;

cout &lt;&lt; dbl &lt;&lt; " : " &lt;&lt; *p1 &lt;&lt; " : " 
    &lt;&lt; *p2 &lt;&lt; " : " &lt;&lt; *p3 &lt;&lt; endl;
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Указатель в никуда</h2>
                    <p>
                        Использование неинициализированных указателей опасно (можно перезаписать произвольную память). 
                        Объявляя указатель, необходимо инициализировать его адресом определенной переменной или нулем. 
                    </p>
                    <p>
                        Поэтому в C++ существует специальное ключевое слово <span class="blue">nullptr</span>,
                        для обозначения пустого указателя (или устаревший вариант, <span class="blue">NULL</span>).
                    </p>
                    <pre>
                    <code class="cpp">
int *pm = nullptr;     // указатель, не указывающий ни на что
...
if (pm == nullptr)
    cout &lt;&lt; endl &lt;&lt; "Нулевой указатель" &lt;&lt; endl;
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <h1>Операции над указателями</h1>
            </section>
            

            <section>
                <h2>Что почитать дополнительно?</h2>
                <ul>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1XxoO8rXvNQvp3DHW5Q31DQES5JHZvLBQ#page=115">
                                <b>Главы 11-17</b> :<br>Г.Перри, Д. Миллер - Программирование на C для начинающих
                            </a>
                        </li>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1sGKwDAXw-JRHN2gyV1YOpdkxlosgixQb#page=142">
                                <b>Глава 4.4</b> :<br>Б.Страуструп - Принципы и практики программирования на C++
                            </a>
                        </li>
                        <a href="https://drive.google.com/uc?export=view&id=1LEiih0sJ41e1SXzf2tYCEnVFcs3eAIAn#page=197">
                            <b>Глава 4-5</b> :<br>Х.М.Дейтейл - Как программировать на C++
                        </a>
                </ul>
            </section>
            
		</div>
	</div>
	<aside id="presentable-icon" class="cpp">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
    <aside id="presentable-icon-close">
        <a title="К списку материалов" href="../../index.html">
            <i class="fa fa-times fa-2x"></i>
        </a>
    </aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>