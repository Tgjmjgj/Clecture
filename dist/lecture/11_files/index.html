<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Files</title>
	<meta name="description" content="files">
	<meta name="keywords" content="files">
	<meta name="author" content="Pavel Karpovich">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	
	<link rel="stylesheet" href="../../css/custom.css" />
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? "../../css/print/pdf.css" : "../../css/print/paper.css";
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<script src="../../js/theme.js"></script>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Основы алгоритмизации и программирования</h1>
                    <h3>Работа с файлами</h3>
                    <div>
                        <p style="display: inline-block;">
                            Pavel Karpovich / 
                        </p>
                        <a href="https://github.com/tgjmjgj" class="icon-button github">
                            <i class="fa fa-github"></i><span></span>
                        </a>
                        <a href="https://facebook.com/paradox7master" class="icon-button facebook">
                            <i class="fa fa-facebook"></i><span></span>
                        </a>
                    </div>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
            <section>
                <h1>Файловый ввод/вывод</h1>
                <blockquote>
                    Файловый ввод/вывод, как и консольный, бывает двух видов:
                </blockquote>
                <ul>
                    <li>Функциональный ввод/вывод (из C)</li>
                    <li>Потоковый ввод/вывод (C++)</li>
                </ul>
            </section>
            <section>
                <section>
                    <h1>Файл - что за фрукт</h1>
                    <blockquote>
                        <i>Файл</i> - это именованный объект, хранящий данные (программа или любая другая информация) на каком-либо
                        носителе (винчестер, CD). Файл, как и массив, - это совокупность данных, потому они немного похожи.
                    </blockquote>
                </section>
                <section>
                    <h2>Отличия файла от массива</h2>
                    <ul>
                        <li>Файлы хранятся не в оперативной памяти, а на внутреннем или внешнем носителе (как правило)</li>
                        <li>Файл не имеет фиксированной длины, т.е. может увеличиваться и уменьшаться сколько угодно</li>
                        <li>Перед работой с файлом его необходимо открыть, а в конце - закрыть</li>
                    </ul>
                </section>
                <section>
                    <h3>Текстовые и бинарные файлы</h3>
                    <blockquote>
                        Грубо говоря, файлы можно разделить на две категории:
                    </blockquote>
                    <ul>
                        <li>
                            Текстовые файлы могут быть просмотрены и отредактированы 
                            с клавиатуры любым текстовым редактором и 
                            имеют простую структуру: последовательность символов. 
                        </li>
                        <li>
                            Бинарные файлы – это файлы, которые не имеют структуры текстовых файлов 
                            и хранят последовательность бит. Каждая программа для своих бинарных 
                            файлов определяет собственную структуру, т.е. чтение таких файлов
                            может оказаться весьма затруднительным.
                        </li>
                    </ul>
                </section>
                <section>
                    <h2>Файлы в C</h2>
                    <blockquote>
                        Все файлы в С рассматриваются как неструктурированная последовательность байтов. Каждый файл
                        завершается маркером конца файла (end-of-file, EOF).
                    </blockquote>
                    <blockquote>
                        Когда файл открывается, то создается программный объект и с этим объектом связывается поток. 
                        Поток – это файл вместе с предоставленными средствами буферизации. Потоки можно открывать и 
                        закрывать (связывать указатели на поток с конкретными файлами); вводить и выводить строку, символ, 
                        форматированные данные, порцию данных произвольной длины; анализировать ошибки ввода/вывода и достижения конца файла; 
                        управлять буферизацией потока и размером буфера; получать и устанавливать указатель текущей позиции в файле.
                    </blockquote>
                </section>
            </section>
            <section>
                <section>
                    <h1>Файловый ввод/вывод С</h1>
                    <blockquote>
                        Функции файлового ввода/вывода С содержатся в той же библиотеке, где и функции для консольного ввода/вывода - <i>stdio.h</i>
                    </blockquote>
                    <blockquote>
                        Также определенный набор функция для работы с файлами находится в библиотеке <i>io.h</i>.
                    </blockquote>
                </section>
                <section>
                    <h3>Функции для работы с файлами</h3>
                    <img src="img/stdio.h.jpg" />
                </section>
                <section>
                    <h3>Функции для работы с файлами 2</h3>
                    <img src="img/stdio.h-2.jpg" />
                </section>
            </section>
            <section>
                <section>
                    <h1>Начало работы с файлом</h1>
                    <blockquote>
                        Прежде чем начать работать с файлом, необходимо
                        инициировать (открыть) поток. При этом поток связывается со 
                        структурой предопределенного типа FILE, 
                        который описан в библиотечном файле &lt;stdio.h&gt;. 
                        Объект этой структуры часто называют дескриптором файла.
                    </blockquote>
                    <blockquote>
                        В конце работы с файлом, тот же поток необходимо будет закрыть.
                    </blockquote>
                </section>
                <section>
                    <h1>Открытие файла</h1>
                    <blockquote>
                        Для открытия файла используется функция <i>fopen</i>.
                    </blockquote>
                    <pre><code class="cpp">
FILE* fopen(char* filename, char* mode);
                    </code></pre>
                    <blockquote>
                        При успешном открытии возвращает указатель на структуру типа FILE - указатель на файл. Эта структура 
                        связана с физическим файлом и используется для всех последующих операций над этим файлом.
                    </blockquote>
                </section>
                <section>
                    <h2>Имя файла</h2>
                    <blockquote>
                        Первый параметр функции <i>fopen</i> - <i>filename</i> служит для передачи имени файла, например
                        "D:\\Work\gifts\shared\нажми_меня.bat".
                    </blockquote>
                    <h3>Замечание!</h3>
                    <blockquote>
                        Поскольку символ обратного слеша \ в языках C/C++ используется для описания спец.символов ('\0','\n','\r'),
                        для записи конкретно обратного слеша используется конструкция из двух знаков: \\.
                        Это нужно учитывать при написании пути к файлу.
                    </blockquote>
                </section>
                <section>
                    <h2>Режимы открытия файла</h2>
                    <table>
                        <tr>
                            <td>Режим</td>
                            <td>Описание</td>
                        </tr>
                        <tr>
                            <td>"w"</td>
                            <td>Открыть файл для записи, если файл существует, то он стирается</td>
                        </tr>
                        <tr>
                            <td>"r"</td>
                            <td>Открыть файл для чтения</td>
                        </tr>
                        <tr>
                            <td>"a"</td>
                            <td>Открыть файл для добавления в конец, если файла нет, то он создается</td>
                        </tr>
                        <tr>
                            <td>"w+"</td>
                            <td>Открыть файл для записи, чтения, исправления. Если файл существует, он стирается</td>
                        </tr>
                        <tr>
                            <td>"r+"</td>
                            <td>Открыть файл для чтения и исправления, однако нельзя увеличивать размер файла</td>
                        </tr>
                        <tr>
                            <td>"a+"</td>
                            <td>Открыть файл для добавления. Как режим "w+", только существующий файл не стирается</td>
                        </tr>
                        <tr>
                            <td>"t"</td>
                            <td>Файл открывается в текстовом режиме (по умолчанию)</td>
                        </tr>
                        <tr>
                            <td>"b"</td>
                            <td>Файл открывается в бинарном режиме</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <ul>
                        <li>
                            Режимы с <i>"w"</i> - создается пустой новый файл. Старый удаляется.
                        </li>
                        <li>
                            Режимы с <i>"r"</i> - индикатор позиции на начало файла, если файл не существует - неудача.
                        </li>
                        <li>
                            Режимы с <i>"a"</i> - индикатор позиции на конец файла, если файл не существует - создается новый.
                        </li>
                    </ul>
                </section>
                <section>
                    <h3>Пример открытия файла</h3>
                    <pre><code class="cpp">
FILE* f;
f = fopen("D:\\programs\explos\init.txt", "tr+");
FILE *fl = fopen("C:\\pagefile.sys", "bw");
                    </code></pre>
                </section>
            </section>
            <section>
                <h1>Закрытие файла</h1>
                <blockquote>
                    После работы с файлом он должен быть закрыт. Для закрытия файла используется функция <i>fclose</i>
                </blockquote>
                <pre><code class="cpp">
                        int fclose(FILE* file);
                </code></pre>
                <blockquote>
                    Функции <i>fclose</i> передается дескриптор файла, который необходимо закрыть.
                </blockquote>
                <blockquote>
                    Если файл не был закрыт в программном коде, система автоматически закроет его при завершении работы программы.
                </blockquote>
            </section>
            <section>
                <h2>Закрытие всех файлов</h2>
                <blockquote>
                    Для закрытия всех ранее открытых файлов используется функция <i>fcloseall</i>
                </blockquote>
                <pre><code>
int fcloseall(void);            
                </code></pre>
                <blockquote>
                    При успешном завершении возвращает количество закрытых потоков.
                </blockquote>
            </section>
            <section>
                <h2>Пример обращения к файлу</h2>
                <pre><code class="cpp">
FILE *fp;
if ((fp = fopen("file.txt", "w")) == NULL)
{
    perror("\nОшибка при открытии файла");  // Выведет сообщение об ошибке
    exit(0);
}
...
fclose(fp);
                </code></pre>
            </section>
            <section>
                <h2>Функция перенаправления потока</h2>
                <blockquote>
                    Если требуется изменить режим доступа к файлу, то для этого сначала необходимо закрыть данный файл, 
                    а затем вновь его открыть, но с другими правами доступа. Для этого уже существует стандартная функция:
                </blockquote>
                <pre><code class="cpp">
FILE* freopen(char* filename, char* mode, FILE* handle);
                </code></pre>
                <blockquote>
                    Эта функция сначала закрывает файл, связанный с дескриптором <i>handle</i>, а затем открывает файл с 
                    именем файла <i>filename</i> и правами доступа <i>mode</i>.
                </blockquote>
            </section>
            <section>
                <h1>Индикатор конца файла</h1>
                <blockquote>
                    Структура <i>FILE</i> содержит индикатор конца файла, который имеет значение 0, пока конец файла не достигнут.
                    Индикатор конца файла перепроверяется после каждой операции чтения.
                </blockquote>
                <blockquote>
                    Состояние конца файла можно получить используя функцию <i>feof</i>.
                </blockquote>
                <pre><code class="cpp">
int feof(FILE *f);
                </code></pre>
                <blockquote>
                    Эта функция возвращает ненулевое значение, если индикатор конца файла установлен, в противном случае возвращается 0.
                </blockquote>
            </section>
            <section>
                <h1>Чтение/запись из файла</h1>
                    Операции по чтению/записи данных из файла можно разделить на три группы:
                <blockquote>
                    <ul>
                        <li>Посимвольный ввод/вывод</li>
                        <li>Построчный ввод/вывод</li>
                        <li>Блочный ввод/вывод</li>
                    </ul>
                </blockquote>
            </section>
            <section>
                <section>
                    <h1>Посимвольный ввод/вывод</h1>
                    <blockquote>
                        В функциях посимвольного ввода/вывода происходит прием одного символа (байта)
                        из файла или передача одного символа в файл.
                    </blockquote>
                    <blockquote>
                        Функция считывания символа из файла:
                    </blockquote>
                    <pre><code class="cpp">
int fgetc(FILE* f);
                    </code></pre>
                    <blockquote>
                        Функция записи символа в файл:
                    </blockquote>
                    <pre><code class="cpp">
int fputc(int ch, FILE* f);
                    </code></pre>
                    <blockquote>
                        После чтения или записи данными функциями индикатор текущей позиции продвигается на следующий символ.
                        При успешном выполнении функции возвращают код символа, иначе - EOF.
                    </blockquote>
                </section>
                <section>
                    <h3>Применение посимвольных функций</h3>
                    <pre><code class="cpp">
FILE* out;
char str[80];
int n = 0;
out = fopen("text.txt", "w");
printf("Input a string:\n");
gets(str);
while(str[n])
{
    fputc(str[n++], out);       // посимвольно записываем строку в файл                            
}
fclose(out);
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h1>Построчный ввод/вывод</h1>
                    <pre><code class="cpp">
int fgets(char* str, int size, FILE* f);
                    </code></pre>
                    <blockquote>
                        Функция <i>fgets</i> выполняет чтение из файла <i>f</i> в строку <i>str</i>
                        <i>size</i> символов. Чтение заканчивается, если встречается символ конца файла или конца строки.
                    </blockquote>
                    <pre><code class="cpp">
int fputs(char* str, FILE* f);
                    </code></pre>
                    <blockquote>
                        Запись в файл <i>f</i> строки <i>str</i> до тех пор, пока не встретится символ '\0', который в файл
                        не переносится и не заменяется на '\n'.
                    </blockquote>
                </section>
                <section>
                    <h3>Применение построчных функций</h3>
                    <pre><code>
FILE* f;
char str[80];
f = fopen("text.txt", "w");
printf("Press Ctrl+Z to exit.\n");
printf("Input a string:\n");
gets(str);
while (!feof(stdin))
{
    fputs(str, f);        // Записываем строку в файл
    putc('\n', f);        // Вручную добавляем символ конца строки
    gets(str);
}
freopen("text.txt", "r", f);                            
if (f == NULL)
{
    printf("Open file failed.\n");
    exit(0);
}
while (fgets(str, 80, in))  // Чтение строк из файла
{
    fputs(str, stdout);     // Вывод строку на консоль                            
}
fclose(f);

                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h1>Блочный ввод/вывод</h1>
                    <blockquote>
                        Функции блочного ввода/вывода позволяют читать и писать в файл содержимое любой структуры.
                    </blockquote>
                    <pre><code class="cpp">
int fread(void* p, int size, int n, FILE* f);
                    </code></pre>
                    <blockquote>
                        Функция <i>fread</i> считывает <i>n</i> блоков размера <i>size</i> байт каждый, из файла
                        <i>f</i> в область памяти по указателю <i>p</i>.
                    </blockquote>
                    <pre><code class="cpp">
int fwrite(void* p, int size, int n, FILE* f);
                    </code></pre>
                    <blockquote>
                        Функция <i>fwrite</i> записывает <i>n</i> блоков по <i>size</i> байт каждый, из области
                        памяти по указателю <i>p</i> в файл <i>f</i>.
                    </blockquote>
                </section>
                <section>
                    <h3>Применение блочных функций</h3>
                    <pre><code class="cpp">
typedef struct emp{
     int code;
     char name;
     double salary; } W;
int n, i;
FILE* out;
W s;
out = fopen("employee.bin", "wb");
printf("Input a number of records to write:");
scanf("%d", &n);
if (n &lt;= 0)
{
    exit(0);                            
}
printf("Input code, name and salary.\n");
for (i = 0; i &lt; n; ++i)
{
    printf("%d> ", i + 1);
    scanf("%d%s%lf", &s.code, &s.name, &s.salary);
    fwrite(&s, sizeof(emp), 1, out);    // Записываем в файл объект структуры emp
}
fclose(out);
FILE* in;
if (!(in = fopen("employee.bin", "rb")))
{
    printf("Open file failed.\n");
    exit(0);
}
int num = 1;
while (fread(&s, sizeof(W), 1, in))
{
    if (feof(in))
    {
        break;
    }
    printf("\n nam &d code=%d name=%s salary=%f\n", num++, s.code, s.name. s.salary);
}
fclose(in);
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h1>Позиционирование в файле</h1>
                    <blockquote>
                        С открытым файлом связано понятие «текущей позиции» (позиционера). 
                        Текущая позиция – номер байта, начиная с которого производится очередная операция чтения/записи.
                    </blockquote>
                    <blockquote>
                        При каждом выполнении функции чтения или записи, указатель смещается на количество прочитанных или записанных байт, 
                        то есть устанавливается сразу за прочитанным или записанным блоком данных в файле. Это так называемый последовательный доступ к данным.
                    </blockquote>
                </section>
                <section>
                    <h2>Функции для взаимодействия с позицией</h2>
                    <blockquote>
                        Текущая позиция представляется в программе переменной типа <i>long</i>. Для работы с ней в стандартной библиотеке имеются три функции: <i>ftell</i>, <i>fseek</i> и <i>rewind</i>.
                    </blockquote>
                </section>
                <section>
                    <h3>Функция ftell</h3>
                    <pre><code class="cpp">
long ftell(FILE* fp);
                    </code></pre>
                    <blockquote>
                        Эта функция возвращает текущую позицию в файле. Если по каким-то причинам текущая позиция не определена, функция возвращает -1L.
                    </blockquote>
                </section>
                <section>
                    <h3>Функция fseek</h3>
                    <pre><code class="cpp">
int fseek(FILE* fp, long pos, int mode);
                    </code></pre>
                    <blockquote>
                        Данная функция позволяет сдвинуть текущую позицию на <i>pos</i> байтов.
                    </blockquote>
                    <blockquote>
                        Третий параметр функции <i>fseek, mode</i>, определяет стартовую точку для изменения позиции в файле. Он может принимать три значения:
                    </blockquote>
                    <ul>
                        <li><i>SEEK_SET</i> - от начала файла, <i>pos</i> всегда &gt;0</li>
                        <li><i>SEEK_CUR</i> - от текущей позиции, <i>pos</i> &gt;0 - вперед, &lt;0 назад</li>
                        <li><i>SEEK_ENG</i> - от конца файла, <i>pos</i> всегда &lt;0</li>
                    </ul>
                </section>
                <section>
                    <h3>Функция rewind</h3>
                    <pre><code class="cpp">
void rewind(FILE* fp);
                    </code></pre>
                    <blockquote>
                        Функция <i>rewind</i> просто перемещает указатель текущей позиции на начало файла.
                    </blockquote>
                </section>
                <section>
                    <h3>Пример управления позицией</h3>
                    <pre><code class="cpp">
FILE *fl = fopen("text.txt", "ta+");
long fsize;
fseek(fl, 0L, SEEK_END);        // Устанавливаем позицию на конец файла
fsize = ftell(fd);              // Получаем значение текущей позиции
printf("Длина файла: %dl байт.\n", fsize);  
                    </code></pre>
                </section>
            </section>
            <section>
                <h2>Дополнительный функции</h2>
                <blockquote>
                    Существует также и другие функции для файлов, например:
                </blockquote>
                <pre><code class="cpp">
int fileno(FILE* fp);
                </code></pre>
                <blockquote>
                    Функция <i>fileno</i> определяет и возвращает числовой дескриптор файла <i>fp</i>.
                </blockquote>
                <pre><code class="cpp">
int filelength(int fd);
                </code></pre>
                <blockquote>
                    Функция <i>filelength</i> возвращает длину файла в байтах, по его числовому дескриптору <i>fd</i>.
                </blockquote>
                <pre><code class="cpp">
int ferror(FILE* fp);
                </code></pre>
                <blockquote>
                    Функция <i>ferror</i> отслеживает появление ошибок, связанных с потоком <i>fp</i>.
                </blockquote>
            </section>
            <section>
                <h2>Переименование файла</h2>
                <blockquote>
                    Для изменения имени файла используется функция <i>rename</i> из библиотеки <i>io.h</i>
                </blockquote>
                <pre><code class="cpp">
int rename(const char* oldname, const char* newname);
                </code></pre>
                <blockquote>
                    В случае успешного переименования функция возвращает 0, иначе - ненулевое значение.
                </blockquote>
            </section>
            <section>
                <h2>Удаление файла</h2>
                <blockquote>
                    Для удаления файла используется функция <i>remove</i>
                </blockquote>
                <pre><code class="cpp">
int remove(const char* filename);
                </code></pre>
                <blockquote>
                    Если на момент удаления файл <i>filename</i> был открыт, то работа функции зависит от конкретной реализации.
                </blockquote>
            </section>
            <section>
                <section>
                    <h1>Потоковый ввод/вывод файлов C++</h1>
                    <blockquote>
                        Для обработки файлов в C++ должны быть включены заголовочные файлы <i>&lt;iostream&gt;</i> и <i>&lt;fstream&gt;</i>.
                    </blockquote>
                    <blockquote>
                        Файл <i>fstream</i> содержит определения классов:
                    </blockquote>
                    <ul>
                        <li><i>ifstream</i> - класс для ввода в файл</li>
                        <li><i>ofstream</i> - класс для вывода из файла</li>
                        <li><i>fstream</i> - класс для ввода/вывода</li>
                    </ul>
                    <blockquote>
                        Файлы открываются путем создания объектов этих классов потоков.
                    </blockquote>
                </section>
                <section>
                    <h2>Иерархия классов ввода/вывода</h2>
                    <img src="img/Ios_classes_hierarchy.jpg" />
                    <blockquote>
                        Таким образом, функции-члены, операции и манипуляторы для работы с потоками, используемые для консольного ввода/вывода, могут быть также применены и к потокам файлов. 
                    </blockquote>
                </section>
                <section>
                    <h3>Пространство имён</h3>
                    <blockquote>
                        При  использовании поточных классов языка С++ в  программе требуется использовать стандартное пространство имен (<i>using namespace::std</i>).
                    </blockquote>
                    <blockquote>
                        Файловый ввод/вывод организован с помощью переопределенных в поточных классах операций включения (&lt;&lt;) и извлечения (&gt;&gt;).
                    </blockquote>
                </section>
            </section>
            <section>
                <section>
                    <h1>Состояние потока</h1>
                    <blockquote>
                        Каждый поток имеет связанное с ним состояние. Состояния потока описываются в классе <i>ios</i> в виде перечисления <i>enum</i>:
                    </blockquote>
                    <pre><code class="cpp">
enum io_state{
        goodbit,        // Нет ошибки 0x00
        eofbit,         // Конец файла 0x01
        failbit,        // Последняя операция не выполнилась 0x02
        badbit,         // Попытка использования недопустимой операции 0x04
        hardfail        // Фатальная ошибка 0x08
             };
                    </code></pre>
                </section>
                <section>
                    <h2>Получение состояния потока</h2>
                    <blockquote>
                        Получить значение состояния потока можно с помощью функции <i>int rdstate()</i>.
                        <p>
                            Кроме того, проверить состояние потока можно следующими функциями:
                        </p>
                    </blockquote>
                    <ul>
                        <li><i>int bad();</i> - возвращает 1, если <i>badbit</i> или <i>hardfail</i></li>
                        <li><i>int eof();</i> - возвращает 1, если <i>eofbit</i></li>
                        <li><i>int fail();</i> - возвращает 1, если <i>failbit</i>, <i>badbit</i> или <i>hardfail</i></li>
                        <li><i>int good();</i> - возвращает 1, если <i>goodbit</i></li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Работа с fstream</h2>
                    <p>
                        Класс fstream используется для открытия файла, чтения и записи, а также перемещения 
                        указателя позиционирования.
                    </p>
                    <p>
                        Чтобы начать работать с ним, нужно создать объект типа fstream:
                    </p>
                    <pre><code class="cpp">
fstream some_name;
                    </code></pre>
                    <p>
                        И дальше, для открытия файла вызвать функцию open.
                    </p>
                    <pre><code class="cpp">
void fstream::open(const char* name, int mode, int p = filebuf::openprot);
                    </code></pre>
                </section>
                <section>
                    <h3>Например</h3>
                    <pre><code class="cpp">
fstream inoutFile;
inoutFile.open(("a.txt", ios_base::out));
if (inoutFile)
{
    // Работа с файлом
}
                    </code></pre>
                </section>
                <section>
                    <h2>Режимы открытия файла</h2>
                    <ul>
                        <li>ios_base::app - Дозапись в конец</li>
                        <li>ios_base::binary - Бинарный режим</li>
                        <li>ios_base::in - Для чтения</li>
                        <li>ios_base::out - Для записи</li>
                        <li>ios_base::trunc - Очистить файл</li>
                        <li>ios_base::ate - Установить указатель позиционирования на конец файла</li>
                    </ul>
                    <p>
                        Для задания нескольких режимов используется оператор побитового ИЛИ (|).  
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Закрытие файла</h2>
                    <p>
                        Для сброса буфера потока, отсоединения  потока от файла и закрытия файла используется функция:
                    </p>
                    <pre><code class="cpp">
void fstream::close();
                    </code></pre>
                    <p>
                        Эту функцию необходимо явно вызвать при изменении режима работы с потоком, и в конце 
                        работы с файлом.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Позиционирование</h2>
                    <p>
                        Для позиционирования в fstream есть 4 функции:
                    </p>
                    <ul>
                        <li>fstream::seekg() - установка позиции для чтения</li>
                        <li>fstream::seekp() - установка позиции для записи</li>
                        <li>fstream::tellg() - получение текущей позиции для чтения</li>
                        <li>fstream::tellp() - получения текущей позиции для записи</li>
                    </ul>
                </section>
                <section>
                    <h2>Установка позиции</h2>
                    <p>
                        Функции позиционирования seekg и seekp имеют следующий формат:
                    </p>
                    <pre><code class="cpp">
fstream::seekg(int offset_position, ios_base::seekdir dir);
fstream::seekp(int offset_position, ios_base::seekdir dir);
                    </code></pre>
                    <p>
                        Первым параметров offset_position идёт число байт, на которое нужно сдвинуть позицию.
                    </p>
                    <p>
                        Второй параметр dir определяет исходную точку сдвига. Может иметь одно из 3 значений:
                    </p>
                    <ul>
                        <li>ios_base::beg - от начала файла</li>
                        <li>ios_base::cur - от текущей позиции</li>
                        <li>ios_base::end - от конца файла</li>
                    </ul>
                </section>
                <section>
                    <h2>Получение позиций</h2>
                    <p>
                        Получение позиций чтения и записи осуществляется при помощи функций 
                        tellg и tellp соответственно.
                    </p>
                    <pre><code class="cpp">
int fstream::tellg();
int fstream::tellp();
                    </code></pre>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre class="cpp">
#include &lt;fstream&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace std;

    char p[100];
    fstream file;
    // Создание двунаправленного потока
    file.open("a.txt", ios_base::in | ios_base::out | ios_base::trunc);
    file &lt;&lt; "This is string" &lt;&lt; endl;       // Вывод в файл
    // Установка позиции на начало
    file.seekg(0, ios_base::beg);
    // Чтение строки из файла
    file.getline(p, 50);
    file.seekg(0, ios_base::beg);
    // Вывод содержимого потока на экран
    cout &lt;&lt; endl &lt;&lt; file.rdbuf();
    inout.close(); // Закрыть поток
}
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Работа с ofsteram</h2>
                    <p>
                        Если файл будет использоваться только для записи, лучше использовать ofstream.
                    </p>
                    <pre><code class="cpp">
ofstream outfile("copy.out", ios_base::out);
ofstream outfile3("copy.out");  // Одно и то же
                    </code></pre>
                </section>
                <section>
                    <h2>Функции записи через ofstream</h2>
                    <p>
                        Для записи одного символа в поток есть функция:
                    </p>
                    <pre><code class="cpp">
ofstream&amp; ofstream::put(char symb);
                    </code></pre>
                    <p>
                        Для записи строки, как массива символов, существует функция:
                    </p>
                    <pre><code class="cpp">
ofstream&amp; ofstream::write(const char* buffer, int size);
                    </code></pre>
                </section>
                <section>
                    <h3>Пример использования ofstream</h3>
                    <pre><code class="cpp">
#include &lt;fstream&gt;

int main()
{
    ofstream out;           // Создаём объект типа ofstream

    out.open("a.txt");      // Открытие файла
    if (out == nullptr)        // Если файл не удалось открыть
    {
        return 0;
    }
    for (int i = 0; i &lt; 2; ++i)     
    {
        out &lt;&lt; "string" &lt;&lt; i &lt;&lt; endl;         // Вывод в файл
    }
    out.close();            // Закрытие файла
}
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Работа с ifsteram</h2>
                    <p>
                        Если файл будет использоваться только для чтения, лучше использовать ifstream.
                    </p>
                </section>
                <section>
                    <h2>Функции ifstream</h2>
                    <p>
                        Для считывания строки:
                    </p>
                    <pre><code class="cpp">
ifstream&amp; ifstream::getline(char* buffer, int size, char delimiter='\n');
                    </code></pre>
                    <p>
                        Для считывания определённого количества символов:
                    </p>
                    <pre><code class="cpp">
ifstream&amp; ifstream::read(char* buffer, int size);
                    </code></pre>
                </section>
                <section>
                    <h3>Пример работы с ifstream</h3>
                    <pre><code class="cpp">
#include &lt;ifstream&gt;

int main()
{
    ifstream in;        // Создаём объект типа ifstream
    char c;

    in.open("C:\\b.txt");           // Открытие файла
    while (!in.eof())           // Пока не конец файла
    {
        c = in.peek();      // Считываем символ из файла без смещения позиции
        
        if (c == 'A')           // Если символ A
        {
            in.seekg(in.tellg() + 1);       // Передвигаем позиционер на один
            continue;
        }
        in.get(c);              // Считывание одного символа
        cout &lt;&lt; c;
    }
    in.close();         // Закрытие файла
}
                    </code></pre>
                </section>
            </section>

            <section>
                <h2>Что почитать дополнительно?</h2>
                <ul>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1XxoO8rXvNQvp3DHW5Q31DQES5JHZvLBQ#page=299">
                                <b>Главы 28-29</b> :<br>Г.Перри, Д. Миллер - Программирование на C для начинающих
                            </a>
                        </li>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1sGKwDAXw-JRHN2gyV1YOpdkxlosgixQb#page=393">
                                <b>Глава 10</b> :<br>Б.Страуструп - Принципы и практики программирования на C++
                            </a>
                        </li>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1LEiih0sJ41e1SXzf2tYCEnVFcs3eAIAn#page=987">
                                <b>Глава 17</b> :<br>Х.М.Дейтейл - Как программировать на C++
                            </a>
                        </li>
                </ul>
            </section>
        </div>
    </div>
	<aside id="presentable-icon" class="cpp">
        <a title="Содержание лекции" href="#/0/1">
            <i class="fa fa-list-ul fa-2x controls"></i>
        </a>
    </aside>
    <aside id="presentable-icon-close">
        <a title="К списку материалов" href="../../index.html#/1">
            <i class="fa fa-times fa-2x controls"></i>
        </a>
    </aside>
    <aside id="presentable-theme-picker">
        <div id="hidden-bar" class="invisible">
            <div>
                <div data-theme="beige" class="theme-circle theme-beige"></div>
                <div data-theme="black" class="theme-circle theme-black"></div>
                <div data-theme="blood" class="theme-circle theme-blood"></div>
                <div data-theme="league" class="theme-circle theme-league"></div>
                <div data-theme="moon" class="theme-circle theme-moon"></div>
                <div data-theme="night" class="theme-circle theme-night"></div>
                <div data-theme="serif" class="theme-circle theme-serif"></div>
                <div data-theme="simple" class="theme-circle theme-simple"></div>
                <div data-theme="sky" class="theme-circle theme-sky"></div>
                <div data-theme="solarized" class="theme-circle theme-solarized"></div>
                <div data-theme="white" class="theme-circle theme-white"></div>
            </div>
        </div>
        <div id="selected-theme" class="theme-circle"></div>
    </aside>
    <script src="../../js/bundle.min.js"></script>
</body>

</html>