<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Arrays</title>
	<meta name="description" content="static arrays">
	<meta name="keywords" content="c, c++">
	<meta name="author" content="Edward & Albert">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Основы алгоритмизации и программирования</h1>
                    <h3>Работа с указателями</h3>
                    <div>
                        <p style="display: inline-block;">
                            Edward &amp; Albert / 
                        </p>
                        <a href="https://github.com/tgjmjgj" class="icon-button github">
                            <i class="fa fa-github"></i><span></span>
                        </a>
                        <a href="https://facebook.com/paradox7master" class="icon-button facebook">
                            <i class="fa fa-facebook"></i><span></span>
                        </a>
                    </div>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
            </section>
            <section>
                <section>
                    <h1>Указатели</h1>
                    <blockquote>
                        Указатель – это объект, значением которого служит адрес другого объекта
                        (переменной, константы, другого указателя) или функций.
                    </blockquote>
                </section>
                <section>
                    <h1>Объявление указателя</h1>
                    <blockquote>
                        Формат объявления указателя:
                        <p><span class="blue">спецификатор_типа</span>* идентификатор</p>
                        <p>
                            Спецификатор_типа задает тип объекта и может быть 
                            любого основного типа, типа структуры или void. 
                        </p>
                    </blockquote>
                    <pre>
                        <code class="cpp">
char *pz;               // указатель на char
int *pk, *pi;           // указатели на int
float *pf;              // указатель на float
                        </code>
                    </pre>
                </section>
                <section>
                    <p>
                        Тип указателя должен однозначно соответствовать типу значения,
                        на адрес которого он указывает.
                    </p>
                    <pre>
                        <code class="cpp">
int name1 = 555;
int* pnm1;
float *pnm2;
char * pnm3;

pnm1 = &amp;name1;          // работает
pnm2 = &amp;name1;          // ошибка
pnm3 = (char*)&amp;name1;   // работает

                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Память компьютера</h2>
                    <p>
                        Память компьютера состоит из огромного количества байт.
                        У каждого байта в памяти есть свой уникальный адрес (номер).
                    </p>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory.jpg">
                </section>
                <section>
                    <h2>Переменная в памяти</h2>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{
    int num;

    // вывод адреса num
    printf("%p \n", &num);
    // 0133FDBD

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory2.jpg">
                </section>
                <section>
                    <h2>Вторая переменная</h2>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{
    int num;
    int* p1 = &amp;num;
    // 0133FDBD

    float big = 12.562;
    char* p2 = &amp;big;
    // 0133FDB2

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory3.jpg">
                </section>
                <section>
                    <h2>И еще массив</h2>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{
    int num;
    int* p1 = &amp;num;
    // 0133FDBD

    float big = 12.562;
    float* p2 = &amp;big;
    // 0133FDA2

    char str[10] = "avial";
    char* p3 = str;
    // 0133FDAC

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory4.jpg">
                </section>
            </section>
            <section>
                <h3>Ещё раз</h3>
                <p>
                    Обычные переменные хранят значения.
                </p>
                <blockquote>
                    Указатели хранят адреса этих значений.
                </blockquote>
                <pre>
                    <code class="cpp">
char sy = '%';
cout &lt;&lt; sy &lt;&lt; endl;         // Выведет %

char* pointer = &amp;sy;
cout &lt;&lt; pointer &lt;&lt; endl;    // Выведет шестнадцатеричную ерунду

int name = 42;
cout &lt;&lt; name &lt;&lt; endl;       // Выведет ответ на главный вопрос жизни, вселенной и всего такого

int* ptr = &amp;name;
cout &lt;&lt; ptr &lt;&lt; endl;        // Выведет шестнадцатеричную ерунду
                    </code>
                </pre>
            </section>
            <section>
                <section>
                    <h3>Как вывести значение по указателю?</h3>
                    <blockquote>
                        Ответ - операция <span class="purple">разыменования</span>.
                    </blockquote>
                    <p>
                        Разыменование, или косвенная адресация - получение переменной не напрямую,
                        а через указатель, содержайщий адрес этой переменной.
                    </p>
                    <p>
                        Обращение с переменной через указатель с её адресом равносильно обращению 
                        с самой переменной. Т.е. допускается перезапись и изменение значения.
                    </p>
                </section>
                <section>
                    <h2>Указатель</h2>
                    <p>
                        По факту, переменная и указатель на эту переменную обращается 
                        к одной и той же памяти, к одному и тому же значению.
                    </p>
                    <blockquote>
                        <ins>
                            Меняя значение по указателю, изменится значение и переменной.
                            Аналогично, меняя значение в переменной, по указателю будет уже
                            новое изменённое значение.
                        </ins>
                    </blockquote>
                    <img src="img/pointer.jpg">
                </section>
                <section>
                    <h3>Использование разыменованного указателя</h3>
                    <pre>
                        <code class="cpp">
int x = 10;
int *p = &amp;x;
printf("Address = %p \n", p);
printf("x = %d \n", *p);

*p += 1;
printf("Address = %p \n", p);   // адрес не изменится
printf("x = %d \n", *p);        // 11
printf("x = %d \n", x);         // 11

x /= 2;
printf("x = %d \n", *p);        // 5
printf("x = %d \n", x);         // 5
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>* и &amp;</h3>
                    <p>
                        Операция разыменования * в некотором смысле является 
                        обратной операции получения адреса &amp;.
                    </p>
                    <pre>
                        <code class="cpp">
int eger = 27;

int* ptr = &amp;eger;

int b = *ptr;           // b = 27

int c = *&amp;b;            // c = b = 27

bool isr = &*ptr == &amp;*&amp;eger;    // true
bool isr = &*ptr == &amp;*&amp;c;       // false
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="cpp">
char c = 'N';
int d = 10;
short s = 2;
    
char *pc = &amp;c;          // получаем адрес переменной с типа char
int *pd = &amp;d;           // получаем адрес переменной d типа int
short *ps = &amp;s;         // получаем адрес переменной s типа short
    
printf("Variable c: address=%p \t value=%c \n", pc, *pc);
printf("Variable d: address=%p \t value=%d \n", pd, *pd);
printf("Variable s: address=%p \t value=%hd \n", ps, *ps);
return 0;
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример 2</h3>
                    <img src="img/multi_pointers.jpg">
                    <pre>
                        <code class="cpp">
double dbl = 6273e+25;
double* p1 = &amp;dbl;
double* p2 = p1;

dbl = 33.543;
double* p3 = &amp;dbl;

*p2 -= 30;

cout &lt;&lt; dbl &lt;&lt; " : " &lt;&lt; *p1 &lt;&lt; " : " 
    &lt;&lt; *p2 &lt;&lt; " : " &lt;&lt; *p3 &lt;&lt; endl;
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Указатель в никуда</h2>
                    <p>
                        Использование неинициализированных указателей опасно (можно перезаписать произвольную память). 
                        Объявляя указатель, необходимо инициализировать его адресом определенной переменной или нулем. 
                    </p>
                    <p>
                        Поэтому в C++ существует специальное ключевое слово <span class="blue">nullptr</span>,
                        для обозначения пустого указателя (или устаревший вариант, <span class="blue">NULL</span>).
                    </p>
                    <pre>
                    <code class="cpp">
int *pm = nullptr;     // указатель, не указывающий ни на что
...
if (pm == nullptr)
    cout &lt;&lt; endl &lt;&lt; "Нулевой указатель" &lt;&lt; endl;
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Ссылки</h2>
                    <p>
                        Ссылка - объект, ссылающийся на другую переменную.
                    </p>
                    <blockquote>
                        Формат объявления ссылки:
                            <p><span class="blue">спецификатор_типа</span>& идентификатор</p>
                    </blockquote>
                    <p>
                        При изменении ссылки изменения будут отражаться и на исходной переменной.
                    </p>
                    <blockquote>
                        Переменная и ссылки на неё - два имени одного и того же объекта в памяти.
                    </blockquote>
                </section>
                <section>
                    <h2>Ссылки</h2>
                    <p>
                        Ссылка всегда должна ссылаться на существующую переменную.
                    </p>
                    <pre>
                        <code class="cpp">
short int g = 13;

short int * pointer = &amp;g;   // Указатель на g
short int & reference = g;      // Ссылка на g
short int b = g;                // Копия g

cout &lt;&lt; "Переменная: " &lt;&lt; g &lt;&lt; endl;          // 13
cout &lt;&lt; "Указатель: " &lt;&lt; pointer &lt;&lt; endl;     // 043D3EA2
cout &lt;&lt; "Ссылка: " &lt;&lt; reference &lt;&lt; endl;      // 13
cout &lt;&lt; "Копия: " &lt;&lt; b &lt;&lt; endl;               // 13

++g;
cout &lt;&lt; "Переменная: " &lt;&lt; g &lt;&lt; endl;                          // 14
cout &lt;&lt; "Разыменованный указатель: " &lt;&lt; pointer &lt;&lt; endl;      // 14
cout &lt;&lt; "Ссылка: " &lt;&lt; reference &lt;&lt; endl;                      // 14
cout &lt;&lt; "Копия: " &lt;&lt; b &lt;&lt; endl;                               // 13

++reference;
cout &lt;&lt; "Переменная: " &lt;&lt; g &lt;&lt; endl;                          // 15
cout &lt;&lt; "Разыменованный указатель: " &lt;&lt; pointer &lt;&lt; endl;      // 15
cout &lt;&lt; "Ссылка: " &lt;&lt; reference &lt;&lt; endl;                      // 15
cout &lt;&lt; "Копия: " &lt;&lt; b &lt;&lt; endl;                               // 13

++*pointer;
cout &lt;&lt; "Переменная: " &lt;&lt; g &lt;&lt; endl;                          // 16
cout &lt;&lt; "Разыменованный указатель: " &lt;&lt; pointer &lt;&lt; endl;      // 16
cout &lt;&lt; "Ссылка: " &lt;&lt; reference &lt;&lt; endl;                      // 16
cout &lt;&lt; "Копия: " &lt;&lt; b &lt;&lt; endl;                               // 13

g = nullptr;                // ошибка
pointer = nullptr;          // pointer больше не указывает на g
reference = nullptr;        // ошибка
b = nullptr;                // ошибка

                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h1>Операции над указателями</h1>
                    <p>
                        Указатели можно использовать в следующих операциях:
                    </p>
                    <ul>
                        <li>Присваивание (=)</li>
                        <li>Разыменование (*)</li>
                        <li>Взятие адреса (&)</li>
                        <li>Сравнения (==, !=, &lt;, &gt;, &lt;=, &gt;=)</li>
                        <li>Некоторая арифметика (+, -, ++, --)</li>
                    </ul>
                </section>
                <section>
                    <h2>Присваивание</h2>
                    <p>
                        Указателю можно присвоить адрес любого объекта в памяти, или 
                        специальные адреса <span class="blue">nullptr</span> и <span class="blue">NULL</span>.
                    </p>
                    <p>
                        Числа присваивать нельзя (без явного приведения к типу указателя).
                    </p>
                    <pre>
                        <code class="cpp">
char symb = '=';
char t;
int kk = -13;

char* pc = &amp;symb;
pc = &amp;t;
pc = &amp;kk;                   // ошибка

printf("%p", &kk);              // 006FFB90

int *ptr_i = 0x006FFB90;        // ошибка
ptr_i = (int*)0x006FFB90;

printf("%d", *ptr_i);           // -13
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Разыменование</h2>
                    <p>
                        Разыменование - специальная операция, применимая только к указателям.
                    </p>
                    <br/>
                    <p>
                        Её примеров мы уже насмотрелись.
                    </p>
                </section>
                <section>
                    <h2>Взятие адреса</h2>
                    <p>
                        Да-да. У указателя тоже есть адрес.
                    </p>
                    <p>
                        Указатель хранит адрес переменной. Хранит. Значит хранит где-то, а где же 
                        еще, кроме как в памяти.
                    </p>
                    <blockquote>
                        Указатель на переменную занимает в памяти 2, 4 или 8 байтов.
                        2 байта на 16 битных системах, 4 на 32 битных и 8 на 64 битных.
                    </blockquote>
                    <p>
                        Размер указателя на функцию может достигать 24 байт.
                    </p>
                </section>
                <section>
                    <h3>Адрес указателя</h3>
                    <pre>
                        <code class="cpp">
int num = 888;
int* pn = &amp;num;

printf("%d", *pn);          // Значение переменной
printf("%p", pn);           // Указатель - адрес переменной
printf("%p", &amp;pn);          // Адрес указателя

printf("%p", &amp;&amp;num);    // Ошибка - у адреса нет адреса

                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Дополним пример с памятью</h3>
                    <div style="display: inline-block;">
                        <pre>
                            <code class="cpp">
int main()
{
    int num;
    int* p1 = &amp;num;
    // &amp;num = 0133FDBD
    // &amp;p1 = 0133FDB9

    float big = 12.562;
    float* p2 = &amp;big;
    // &amp;big = 0133FDB1
    // &amp;p2 = 0133FDAD

    char str[10] = "avial";
    char* p3 = str;
    // &amp;str = 0133FDA3
    // &amp;p3 = 0133FD9F

    return 0;
}
                            </code>
                        </pre>
                    </div>
                    <img style="float: right;" src="img/memory5.jpg">
                </section>
                <section>
                    <h2>Операции сравнения</h2>
                    <p>
                        Указатели можно сравнивать между собой всеми доступными
                        операторами сравнения (==, !=, &lt;, &gt;, &lt;=, &gt;=).
                    </p>
                    <p>
                        Сравниваться будут значения адресов, записанных в указателях, 
                        как простые числа.
                    </p>
                    <p>
                        Сравнение указателей бывает полезно при работе с массивами.
                    </p>
                </section>
                <section>
                    <h3>Примеры сравнений</h3>
                    <pre>
                        <code class="cpp">
int a = 3;
int b = 17;

int* pa = &amp;a;           //  003FF47A
int* pb = &amp;b;           //  003FF471

bool b1 = (a &lt; b);               // true
bool b2 = (pa &lt; pb);             // false

int mas[2] = { 14, -234 };
pa = &mas[0];
pb = &mas[1];
if (pa > pb)
{
    printf("%d идёт после %d", *pa, *pb);
}
else
{
    printf("%d идёт после %d", *pb, *pa);
}
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Арифметика указателей</h2>
                    <p>
                        К указателям можно прибавлять значения, и отнимать значения.
                        Т.е. доступны операции + и -, а также их сокращённые формы +=, -=, ++ и --.
                    </p>
                    <p>
                        В качестве вторых операндов могут выступать целые числа и другие указатели.
                    </p>
                    <blockquote>
                        В результате операций изменяется адрес, на который указывает указатель.
                    </blockquote>
                </section>
                <section>
                    <h2>Особенности вычислений</h2>
                    <p>
                        Но эти операции выполняются по особенному, не так как с обычными числами.
                    </p>
                    <blockquote>
                        <span class="red">
                            При добавлении к указателю числа N, адрес смещается 
                            на расстояние в N элементов <ins>типа указателя</ins>.
                        </span>
                    </blockquote>
                    <p>
                        При прибавлении адрес увеличивается, при вычитании уменьшается.
                    </p>
                </section>
            </section>

            <section>
                <h2>Что почитать дополнительно?</h2>
                <ul>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1XxoO8rXvNQvp3DHW5Q31DQES5JHZvLBQ#page=115">
                                <b>Главы 11-17</b> :<br>Г.Перри, Д. Миллер - Программирование на C для начинающих
                            </a>
                        </li>
                        <li>
                            <a href="https://drive.google.com/uc?export=view&id=1sGKwDAXw-JRHN2gyV1YOpdkxlosgixQb#page=142">
                                <b>Глава 4.4</b> :<br>Б.Страуструп - Принципы и практики программирования на C++
                            </a>
                        </li>
                        <a href="https://drive.google.com/uc?export=view&id=1LEiih0sJ41e1SXzf2tYCEnVFcs3eAIAn#page=197">
                            <b>Глава 4-5</b> :<br>Х.М.Дейтейл - Как программировать на C++
                        </a>
                </ul>
            </section>
            
		</div>
	</div>
	<aside id="presentable-icon" class="cpp">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x"></i>
		</a>
	</aside>
    <aside id="presentable-icon-close">
        <a title="К списку материалов" href="../../index.html">
            <i class="fa fa-times fa-2x"></i>
        </a>
    </aside>
	<script src="../../js/bundle.min.js"></script>
</body>

</html>